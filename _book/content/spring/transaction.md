# Transaction



- [Introduction](#introduction)
- [ACID properties](#acid-properties)
- [State of transaction](#state-of-transaction)
- [Spring Transaction](#spring-transaction)
  - [Programmatic transaction](#programmatic-transaction)
  - [Declarative transaction](#declarative-transaction)
  - [Propagation](#propagation)
  - [Isolation](#isolation)



#### Introduction

A **transaction** is a set of logically related operations. For example, you are transferring money from your bank account to your friend’s account, the set of operations would be like this:

**Simple Transaction Example**

1. Read your account balance
2. Deduct the amount from your balance
3. Write the remaining balance to your account
4. Read your friend’s account balance
5. Add the amount to his account balance
6. Write the new updated balance to his account

This whole set of operations can be called a transaction. Although I have shown you read, write and update operations in the above example but the transaction can have operations like read, write, insert, update, delete.



#### ACID properties

To ensure the integrity of data during a transaction (**A transaction is a unit of program that updates various data items, read more about it here**), the database system maintains the following properties. These properties are widely known as ACID properties:

1.  **Atomicity**: This property ensures that either all the operations of a transaction reflect in database or none. Let’s take an example of banking system to understand this: Suppose Account **A** has a balance of 400$ & **B** has 700$. Account **A** is transferring 100$ to Account **B**. This is a transaction that has two operations a) Debiting 100$ from A’s balance b) Creating 100$ to B’s balance. Let’s say first operation passed successfully while second failed, in this case A’s balance would be 300$ while B would be having 700$ instead of 800$. This is unacceptable in a banking system. Either the transaction should fail without executing any of the operation or it should process both the operations. The Atomicity property ensures that.
2.  **Consistency** - To preserve the consistency of database, the execution of transaction should take place in isolation (that means no other transaction should run concurrently when there is a transaction already running). For example account A is having a balance of 400$ and it is transferring 100$ to account B & C both. So we have two transactions here. Let’s say these transactions run concurrently and both the transactions read 400$ balance, in that case the final balance of A would be 300$ instead of 200$. This is wrong. If the transaction were to run in isolation then the second transaction would have read the correct balance 300$ (before debiting 100$) once the first transaction went successful.
3.  **Isolation** - For every pair of transactions, one transaction should start execution only when the other finished execution.
4. **Durability** - Once a transaction completes successfully, the changes it has made into the database should be permanent even if there is a system failure.



#### State of transaction

1. Active state (in execution)
2. Failed state (hardware failure or a software failure)
3. Partially committed state (Committed but not write to database)
4. Committed state
5. Aborted State (fail during execution)



#### Spring transaction

1. [Programmatic transaction](#programmatic-transaction)
2. [Declarative transaction](#declarative-transaction)



#### Programmatic transaction

There are two way to implement programmatic transaction **PlatformTransactionManager** and **TransactionTemplate**.

**TransactionTemplate**

TransactionTemplate will use TransactionManager internally, which will use a data source.

```java
@Service
public class UserService {

    @Autowired
    private TransactionTemplate template;

    public Long registerUser(User user) {
        Long id = template.execute(status ->  {
            // execute some SQL that e.g.
            // inserts the user into the db and returns the autogenerated id
            return id;
        });
    }
}
```

**PlatformTransactionManager**

```java
public interface PlatformTransactionManager {
   TransactionStatus getTransaction(TransactionDefinition definition);
   throws TransactionException;
   
   void commit(TransactionStatus status) throws TransactionException;
   void rollback(TransactionStatus status) throws TransactionException;
}
```

***TransactionDefinition* **

The *TransactionDefinition* is the core interface of the transaction support in Spring and it is defined as follows. DefaultTransactionDefinition is the class implements TransactionDefinition

```java
public interface TransactionDefinition {
   int getPropagationBehavior();
   int getIsolationLevel();
   String getName();
   int getTimeout();
   boolean isReadOnly();
}
```

**TransactionStatus**

The *TransactionStatus* interface provides a simple way for transactional code to control transaction execution and query transaction status.

```java
public interface TransactionStatus extends SavepointManager {
   boolean isNewTransaction();
   boolean hasSavepoint();
   void setRollbackOnly();
   boolean isRollbackOnly();
   boolean isCompleted();
}
```



#### Declarative transaction

**Declarative** transaction management approach allows you to manage the transaction with the help of configuration instead of hard coding in your source code. This means that you can separate transaction management from the business code. You only use annotations or XML based configuration to manage the transactions. Spring AOP is used for declarative transaction.

1. [XML Based](#xml-based)
2. [Annotation Based](#annotation-based)

##### XML Based

```java
<!-- Initialization for TransactionManager -->
<bean id = "transactionManager"
	class = "org.springframework.jdbc.datasource.DataSourceTransactionManager">      
		<property name = "dataSource" ref = "dataSource" />    
</bean>

<tx:advice id = "txAdvice" transaction-manager = "transactionManager">
	<tx:attributes>
      	<tx:method name = "get*" read-only="true"/>      	
		<tx:method name="*"/>
     </tx:attributes>
</tx:advice>

<aop:config>
    <aop:pointcut id="userServiceOperation" expression="execution(* x.y.service.UserService.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="userServiceOperation"/>
</aop:config>
```



##### Annotation Based

```java
public class UserService {

    @Transactional
    public Long registerUser(User user) {
       // execute some SQL that e.g.
        // inserts the user into the db and retrieves the autogenerated id
        // userDao.save(user);
        return id;
    }
}
```

**Note:-**

- Make sure that your Spring Configuration is annotated with the @EnableTransactionManagement annotation (In Spring Boot this will be done *automatically for you*).
- Make sure you specify a transaction manager in your Spring Configuration (this you need to do anyway).
- And then Spring is smart enough to transparently handle transactions for you: Any bean’s *public* method you annotate with the @Transactional annotation



#### Propagation

**Propagation** is the ability to decide how the business methods should be encapsulated in both logical or physical **transactions**.

- **Required**(default) - method needs a transaction, either open one for me or use an existing one
- **Require_new** - Creates a new transaction, suspending the current transaction if one exists.
- **Supports** - Supports a current transaction; executes non - transactionally if none exists.
- **Not_Supported** - Does not support a current transaction; rather always execute non transactionally.
- **Mandatory** - Supports a current transaction; throws an exception if no current transaction exists.
- **Never** - Does not support a current transaction; throws an exception if a current transaction exists.
- **Nested** - Executes within a nested transaction if a current transaction exists. (savePoint)

#### Isolation

- **READ_UNCOMMITTED** - isolation level states that a transaction **may** read data that is still **uncommitted** by other transactions.

- **READ_COMMITTED** - isolation level states that a transaction can't read data that is **not** yet committed by other transactions. This means that the **dirty read** is no longer an issue, but even this way other issues may occur. Example **Transaction A** reads some record. Then **Transaction B** writes that same record and commits. Later **Transaction A** reads that same record again and may get different values because **Transaction B** made changes to that record and committed. 

- **REPEATABLE_READ** - isolation level states that if a transaction reads one record from the database multiple times the result of all those reading operations must always be the same. This eliminates both the **dirty read** and the **non-repeatable read** issues, but even this way other issues may occur.

  But in the re-execution of range-queries, we may get newly added or removed rows. Moreover, it is the lowest required level to prevent the lost update. The lost update occurs when two or more concurrent transactions read and update the same row. *REPEATABLE_READ* does not allow simultaneous access to a row at all. Hence the lost update can't happen.

  **REPEATABLE_READ** is the default level in MySQL. **Oracle** does not support **REPEATABLE_READ**.

- **SERIALIZABLE** - isolation level is the most restrictive of all isolation levels. Transactions are executed with locking at all levels (**read**, **range** and **write** locking) so they appear as if they were executed in a serialized way. But in the other way we don't allow transaction concurrency and consequently introduce a performance penalty.

- **DEFAULT** - isolation level, as the name states, uses the default isolation level of the datastore we are actually connecting from our application.